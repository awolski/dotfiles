#+TITLE: Emacs configuration file
#+AUTHOR: Tony Wolski
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* About

This is a copy of [[https://github.com/larstvei/dot-emacs]] that I'm adapting for
my own use.

This is an Emacs configuration file written in [[http://orgmode.org][Org mode]]. It is an attempt to
keep my =~/.emacs.d= tidy, but still be able to keep it all in one file. I aim
to briefly explain all my configurations as I go along!

I would not recommend using this configuration /as-is/, because it probably
contains a lot you don't really need. I do, however, hope people find some
golden nuggets that they can smuggle into their own configs.

If you really do want to try this config out, this is how I'd go about it:

Clone the repo.
#+BEGIN_SRC sh :tangle no
git clone https://github.com/larstvei/dot-emacs
#+END_SRC

Backup your old =~/.emacs.d= (if necessary).
#+BEGIN_SRC sh :tangle no
mv ~/.emacs.d ~/.emacs.d-bak
#+END_SRC

Backup your old =~/.emacs=-file (if necessary).
#+BEGIN_SRC sh :tangle no
mv ~/.emacs ~/.emacs-bak
#+END_SRC

And finally
#+BEGIN_SRC sh :tangle no
mv dot-emacs ~/.emacs.d
#+END_SRC

On first run it should install a bunch of packages (this might take a while),
and you might have to restart your Emacs the first time. If you experience
bugs, please let me know!

* Configurations
** Meta

All changes to the configuration should be done in =init.org=, *not* in
=init.el=. Any changes in the =init.el= will be overwritten by saving
=init.org=. The =init.el= in this repo should not be tracked by git, and is
replaced the first time Emacs is started (assuming it has been renamed to
=~/.emacs.d=).

Emacs can't load =.org=-files directly, but =org-mode= provides functions to
extract the code blocks and write them to a file. There are multiple ways of
handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one could just use
=org-babel-load-file=, but I had problems with byte-compilation. Previously I
tracked both the =org.=- and =el.=-files, but the git commits got a little
messy. So here is a new approach.

When this configuration is loaded for the first time, the ~init.el~ is the file
that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
;; This file replaces itself with the actual configuration at first run.

;; We can't tangle without org!
(require 'org)
;; Open the configuration
(find-file (concat user-emacs-directory "init.org"))
;; tangle it
(org-babel-tangle)
;; load it
(load-file (concat user-emacs-directory "init.el"))
;; finally byte-compile it
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

It tangles the org-file, so that this file is overwritten with the actual
configuration.

There is no reason to track the =init.el= that is generated; by running
the following command =git= will not bother tracking it:

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If one wishes to make changes to the repo-version of =init.el= start
tracking again with:

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

The =init.el= should (after the first run) mirror the source blocks in
the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
extracts the code blocks from the current file into a source-specific
file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to
the =after-save-hook= ensuring to always tangle and byte-compile the
=org=-document after changes.

#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "If the current buffer is 'init.org' the code-blocks are
   tangled, and the tangled file is compiled."
  (when (equal (buffer-file-name)
               (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle)
      (byte-compile-file (concat user-emacs-directory "init.el")))))

(add-hook 'after-save-hook 'tangle-init)
#+END_SRC

I'd like to keep a few settings private, so we load a =private.el= if it
exists after the init-file has loaded.

#+BEGIN_SRC emacs-lisp
(add-hook
 'after-init-hook
 (lambda ()
   (let ((private-file (concat user-emacs-directory "private.el")))
     (when (file-exists-p private-file)
       (load-file private-file))
     (when custom-file
       (load-file custom-file))
     (server-start))))
#+END_SRC

A common optimization is to temporarily disable garbage collection during
initialization. Here, we set the ~gc-cons-threshold~ to a ridiculously large
number, and restore the default value after initialization.

#+BEGIN_SRC emacs-lisp
(let ((old-gc-treshold gc-cons-threshold))
  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'after-init-hook
            (lambda () (setq gc-cons-threshold old-gc-treshold))))
#+END_SRC

** Packages

Let's use [[https://github.com/radian-software/straight.el][straight.el]]: next-generation, purely functional package manager for
the Emacs hacker, to manage our packages. First we need to initialise it.

;;#+begin_src emacs-lisp
;;(defvar bootstrap-version)
;;(let ((bootstrap-file
;;       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
;;      (bootstrap-version 6))
;;  (unless (file-exists-p bootstrap-file)
;;    (with-current-buffer
;;        (url-retrieve-synchronously
;;         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
;;         'silent 'inhibit-cookies)
;;      (goto-char (point-max))
;;      (eval-print-last-sexp)))
;;  (load bootstrap-file nil 'nomessage))
;;
;; Disable package.el in favor of straight.el
;;(setq package-enable-at-startup nil)

;; Install use-package
;;(straight-use-package 'use-package)

;; Configure use-package to use straight.el by default
;;(use-package straight
;;  :custom
;;  (straight-use-package-by-default t))
;;#+end_src

Let's test use-package and straight by installing and configuring ledger.

;;#+begin_src emacs-lisp
;;(use-package ledger-mode)
;;#+end_src

;;#+begin_src emacs-lisp
;;(use-package elfeed
;;  :straight t
;;  :ensure t)
;;#+end_src

;;#+begin_src emacs-lisp
;;;; data is stored in ~/.elfeed
;;(setq elfeed-feeds
;;        '(
;;          ;; programming
;;          ("https://jacobian.org/feed/" test)
;;          ("https://news.ycombinator.com/rss" hacker)
;;         ))
;;
;;(setq-default elfeed-search-filter "@2-days-ago +unread")
;;(setq-default elfeed-search-title-max-width 100)
;;(setq-default elfeed-search-title-min-width 100)
;;#+end_src

;;#+begin_src emacs-lisp
;;(use-package org)
;;#+end_src
;;
;;#+begin_src emacs-lisp
;;(use-package org-contrib)
;;#+end_src

;;#+begin_src emacs-lisp
;;(straight-use-package 'company)              ; Modular text completion framework
;;(straight-use-package 'counsel)              ; Various completion functions using Ivy
;;(straight-use-package 'counsel-jq)           ; Traverse complex JSON and YAML structures with live feedback
;;(straight-use-package 'counsel-projectile)   ; Ivy integration for Projectile
;;(straight-use-package 'define-word)          ; display the definition of word at point
;;(straight-use-package 'diff-hl)              ; Highlight uncommitted changes using VC
;;(straight-use-package 'doom-themes)          ; An opinionated pack of modern color-themes
;;(straight-use-package 'eglot)                ; Emacs Polyglot; LSP client that stays out of your way
;;(straight-use-package 'emms)                 ; Emacs multi-Media System, a media player
;;(straight-use-package 'focus)                ; Dim color of text in surrounding sections
;;(straight-use-package 'forge)                ; Work with Git Forges, like GitHub, in Magit
;;(straight-use-package 'format-all)           ; Auto-format code in many languages
;;(straight-use-package 'golden-ratio)         ; Automatic resizing windows to golden ratio
;;(straight-use-package 'js2-mode)             ; Improved JavaScript editing mode
;;(straight-use-package 'ledger-mode)          ; Major mode for editing ledger files
;;(straight-use-package 'magit)                ; control Git from Emacs
;;(straight-use-package 'markdown-mode)        ; Emacs Major mode for Markdown-formatted files
;;(straight-use-package 'multiple-cursors)     ; Multiple cursors for Emacs
;;(straight-use-package 'multi-vterm)          ; Manage multiple vterms in Emacs
;;(straight-use-package 'ob-http)              ; Make http request within org-mode babel
;;(straight-use-package 'olivetti)             ; Minor mode for a nice writing environment
;;(straight-use-package 'org)                  ; Outline-based notes management and organizer
;;(straight-use-package 'org-bullets)          ; Show bullets in org-mode as UTF-8 characters
;;(straight-use-package 'org-ql)               ; Org query language, includes search commands and saved views
;;(straight-use-package 'orgit)                ; Link to Magit buffers from Org documents
;;(straight-use-package 'orgit-forge)          ; Org links to Forge Issue buffers
;;(straight-use-package 'paredit)              ; minor mode for editing parentheses
;;(straight-use-package 'pass)                 ; Password management with pass
;;(straight-use-package 'password-store)       ; Use password-store for auth-source
;;(straight-use-package 'pdf-tools)            ; Emacs support library for PDF files
;;(straight-use-package 'pinentry)             ; Allows pinentry prompt via minibuffer
;;(straight-use-package 'powerthesaurus)       ; Powerthesaurus integration for Emacs
;;(straight-use-package 'projectile)           ; Manage and navigate projects in Emacs easily
;;(straight-use-package 'restclient)           ; HTTP REST client tool for Emacs
;;(straight-use-package 'slime)                ; Superior Lisp Interaction Mode for Emacs
;;(straight-use-package 'smex)                 ; M-x interface with Ido-style fuzzy matching
;;(straight-use-package 'sqlite3)              ; sqlite3 database engine
;;(straight-use-package 'terraform-mode)       ; Major mode for editing Terraform files
;;(straight-use-package 'try)                  ; Try out Emacs packages
;;(straight-use-package 'use-package)          ; Use-package declaration for simplifying your .emacs
;;(straight-use-package 'vterm)                ; A terminal via libvterm
;;(straight-use-package 'web-mode)             ; Major mode for editing HTML, CSS, JavaScript
;;(straight-use-package 'which-key)            ; Display available keybindings in popup
;;(straight-use-package 'yaml-mode)            ; Major mode for editing YAML
;;#+end_src


   Managing extensions for Emacs is simplified using =package= which is
   built in to Emacs 24 and newer. To load downloaded packages we need to
   initialize =package=. =cl= is a library that contains many functions from
   Conmmon Lisp, and comes in handy quite often, so we want to make sure it's
   loaded, along with =package=, which is obviously needed.

   #+BEGIN_SRC emacs-lisp
   (require 'package)
   (package-initialize)
   #+END_SRC

   Packages can be fetched from different mirrors, [[http://melpa.milkbox.net/#/][melpa]] is the largest
   archive and is well maintained.

   #+BEGIN_SRC emacs-lisp
   (setq package-archives
      '(("melpa" . "https://melpa.org/packages/")
        ("gnu" . "https://elpa.gnu.org/packages/")
        ("nongnu" . "https://elpa.nongnu.org/nongnu/"))
      package-archive-priorities
      '(("melpa" . 5)
        ("nongnu" . 4)
        ("gnu" . 3)))
   #+END_SRC

   The configuration assumes that the packages listed below are
   installed. To ensure we install missing packages if they are missing.

   #+BEGIN_SRC emacs-lisp
   (let* ((package--builtins nil)
          (packages
           '(auto-compile         ; automatically compile Emacs libraries
             ;;cider                ; Clojure Interactive Development Environment
             ;;clj-refactor         ; Commands for refactoring Clojure code
             company              ; Modular text completion framework
             ;;company-coq          ; A collection of extensions PG's Coq mode
             counsel              ; Various completion functions using Ivy
             counsel-jq           ; Traverse complex JSON and YAML structures with live feedback
             counsel-projectile   ; Ivy integration for Projectile
             define-word          ; display the definition of word at point
             diff-hl              ; Highlight uncommitted changes using VC
             doom-themes          ; An opinionated pack of modern color-themes
             eglot                ; Emacs Polyglot; LSP client that stays out of your way
             emms                 ; Emacs multi-Media System, a media player
             ;;expand-region        ; Increase selected region by semantic units
             focus                ; Dim color of text in surrounding sections
             ;;flycheck             ; Modern on-the-fly syntax checking
             ;;flycheck-ledger      ; Syntax checking for ledger
             forge                ; Work with Git Forges, like GitHub, in Magit
             format-all           ; Auto-format code in many languages
             golden-ratio         ; Automatic resizing windows to golden ratio
             ;;jedi                 ; Python auto-completion for Emacs
             js2-mode             ; Improved JavaScript editing mode
             ;;ledger-mode          ; Major mode for editing ledger files
             magit                ; control Git from Emacs
             magit-todos          ; Show TODOs (and FIXMEs, etc) in Magit status buffer
             markdown-mode        ; Emacs Major mode for Markdown-formatted files
             multiple-cursors     ; Multiple cursors for Emacs
             multi-vterm          ; Manage multiple vterms in Emacs
             ob-http              ; Make http request within org-mode babel
             olivetti             ; Minor mode for a nice writing environment
             org                  ; Outline-based notes management and organizer
             org-bullets          ; Show bullets in org-mode as UTF-8 characters
             org-contrib          ; Org-mode contributed packages
             org-journal          ; Simple org-mode based journaling mode
             org-ql               ; Org query language, includes search commands and saved views
             orgit                ; Link to Magit buffers from Org documents
             orgit-forge          ; Org links to Forge Issue buffers
             ;;org-roam             ; Roam Research replica with Org-mode
             ;;org-roam-server      ; Org Roam Database Visualizer
             ox-hugo              ; A carefully crafted Org exporter back-end for Hugo
             paredit              ; minor mode for editing parentheses
             pass                 ; Password management with pass
             password-store       ; Use password-store for auth-source
             pdf-tools            ; Emacs support library for PDF files
             pinentry             ; Allows pinentry prompt via minibuffer
             powerthesaurus       ; Powerthesaurus integration for Emacs
             projectile           ; Manage and navigate projects in Emacs easily
             restclient           ; HTTP REST client tool for Emacs
             slime                ; Superior Lisp Interaction Mode for Emacs
             smex                 ; M-x interface with Ido-style fuzzy matching
             terraform-mode       ; Major mode for editing Terraform files
             sqlite3              ; sqlite3 database engine
             try                  ; Try out Emacs packages
             visual-fill-column   ; Wrap visual-line-mode buffers at fill-column
             vterm                ; A terminal via libvterm
             web-mode             ; Major mode for editing HTML, CSS, JavaScript
             which-key            ; Display available keybindings in popup
             yaml-pro             ; Edit YAML in Emacs like a pro
             yasnippet            ; A template system for Emacs
             )))
     (let ((packages (seq-remove 'package-installed-p packages)))
       (print packages)
       (when packages
         ;; Install uninstalled packages
         (package-refresh-contents)
         (mapc 'package-install packages))))
   #+END_SRC

** Sane defaults

   These are what /I/ consider to be saner defaults.

   We can set variables to whatever value we'd like using =setq=.

   #+BEGIN_SRC emacs-lisp
   (setq auto-revert-interval 1            ; Refresh buffers fast
         default-input-method "TeX"        ; Use TeX when toggling input method
         echo-keystrokes 0.1               ; Show keystrokes asap
         inhibit-startup-screen t          ; No splash screen please
         initial-scratch-message nil       ; Clean scratch buffer
         recentf-max-saved-items 100       ; Show more recent files
         ring-bell-function 'ignore        ; Quiet
         scroll-margin 1                   ; Space between cursor and top/bottom
         sentence-end-double-space nil     ; No double space
         custom-file                       ; Customizations in a separate file
         (concat user-emacs-directory "custom.el"))
   #+END_SRC

   Some variables are buffer-local, so changing them using =setq= will only
   change them in a single buffer. Using =setq-default= we change the
   buffer-local variable's default value.

   #+BEGIN_SRC emacs-lisp
   (setq-default tab-width 4                       ; Smaller tabs
                 fill-column 79                    ; Maximum line width
                 truncate-lines t                  ; Don't fold lines
                 indent-tabs-mode nil              ; Use spaces instead of tabs
                 split-width-threshold 160         ; Split verticly by default
                 split-height-threshold nil        ; Split verticly by default
                 frame-resize-pixelwise t          ; Fine-grained frame resize
                 auto-fill-function 'do-auto-fill) ; Auto-fill-mode everywhere
   #+END_SRC

   The =load-path= specifies where Emacs should look for =.el=-files (or
   Emacs lisp files). I have a directory called =site-lisp= where I keep all
   extensions that have been installed manually (these are mostly my own
   projects).

   #+BEGIN_SRC emacs-lisp
   (let ((default-directory (concat user-emacs-directory "site-lisp/")))
     (when (file-exists-p default-directory)
       (setq load-path
             (append
              (let ((load-path (copy-sequence load-path)))
                (normal-top-level-add-subdirs-to-load-path)) load-path))))
   #+END_SRC

   Answering /yes/ and /no/ to each question from Emacs can be tedious, a
   single /y/ or /n/ will suffice.

   #+BEGIN_SRC emacs-lisp
   (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   To avoid file system clutter we put all auto saved files in a single
   directory.

   #+BEGIN_SRC emacs-lisp
   (defvar emacs-autosave-directory
     (concat user-emacs-directory "autosaves/")
     "This variable dictates where to put auto saves. It is set to a
     directory called autosaves located wherever your .emacs.d/ is
     located.")

   ;; Sets all files to be backed up and auto saved in a single directory.
   (setq backup-directory-alist
         `((".*" . ,emacs-autosave-directory))
         auto-save-file-name-transforms
         `((".*" ,emacs-autosave-directory t)))
   #+END_SRC

   Set =utf-8= as preferred coding system.

   #+BEGIN_SRC emacs-lisp
   (set-language-environment "UTF-8")
   #+END_SRC

   Use emacs for pinentry.

   #+begin_src emacs-lisp
   (setq epg-pinentry-mode 'loopback)
   (pinentry-start)
   #+end_src

   When I /wouldn't/ I want to remove whitespace when saving a file?

   #+begin_src emacs-lisp
   (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+end_src

   By default the =narrow-to-region= command is disabled and issues a
   warning, because it might confuse new users. I find it useful sometimes,
   and don't want to be warned.

;;   #+BEGIN_SRC emacs-lisp
;;   (put 'narrow-to-region 'disabled nil)
;;   #+END_SRC

   Automatically revert =doc-view=-buffers when the file changes on disk.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'doc-view-mode-hook 'auto-revert-mode)
   #+END_SRC

** Modes

   There are some modes that are enabled by default that I don't find
   particularly useful. We create a list of these modes, and disable all of
   these.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(menu-bar-mode                ; No menu bar, more room for text
              tool-bar-mode                ; No toolbars, more room for text
              scroll-bar-mode              ; No scroll bars either
              blink-cursor-mode))          ; The blinking cursor gets old
     (funcall mode 0))
   #+END_SRC

   Let's apply the same technique for enabling modes that are disabled by
   default.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(abbrev-mode                  ; E.g. sopl -> System.out.println
              column-number-mode           ; Show column number in mode line
              delete-selection-mode        ; Replace selected text
              dirtrack-mode                ; directory tracking in *shell*
              global-company-mode          ; Auto-completion everywhere
              global-diff-hl-mode          ; Highlight uncommitted changes
              ;;global-flycheck-mode         ; Enable syntax checking with flycheck
              global-so-long-mode          ; Mitigate performance for long lines
              counsel-projectile-mode      ; Manage and navigate projects
              recentf-mode                 ; Recently opened files
              show-paren-mode              ; Highlight matching parentheses
              which-key-mode))             ; Available keybindings in popup
     (funcall mode 1))

   (when (version< emacs-version "24.4")
     (eval-after-load 'auto-compile
       '(auto-compile-on-save-mode 1)))   ; compile .el files on save
   #+END_SRC

** Pass

   I use the awesome [[https://www.passwordstore.org/][pass]], the standard unix password manager, to manage
   secrets securely.

   #+begin_src emacs-lisp
   (auth-source-pass-enable)
   (setq auth-source-debug t)
   (setq auth-source-do-cache nil)
   (setq auth-sources '(password-store))
   #+end_src

** Mail

   I'm testing out mu4e to manage my mail.

   #+begin_src emacs-lisp
   (require 'mu4e)

   (require 'mu4e-org)
   (require 'smtpmail)

   (setq send-mail-function 'smtpmail-send-it
         smtpmail-debug-info t
         message-kill-buffer-on-exit t
         mu4e-get-mail-command "mbsync -a"
         ;; mu4e-update-interval (* 60 60)
         ;; Prevent 'Maildir error: duplicate UID <id>' errors
         mu4e-change-filenames-when-moving t
         mu4e-attachment-dir "~/Downloads"
         ;; Only ask if a context hasn't been previously picked
         mu4e-compose-context-policy 'ask-if-none
         auth-source-debug t)

   (setq mu4e-contexts
         (list
          ;; awolski.com account
          (make-mu4e-context
           :name "awolski"
           :match-func
           (lambda (msg)
             (when msg
               (string-prefix-p "/awolski" (mu4e-message-field msg :maildir))))
           :vars '((user-mail-address      . "tony@awolski.com")
                   (user-full-name         . "Tony Wolski")
                   (mu4e-compose-signature . "Tony\n\n\https://awol.ski")
                   (smtpmail-smtp-user     . "tony@awolski.com")
                   (smtpmail-smtp-server   . "smtp.fastmail.com")
                   (smtpmail-smtp-service  . 587)
                   (smtpmail-stream-type   . starttls)
                   (mu4e-drafts-folder     . "/awolski/Drafts")
                   (mu4e-sent-folder       . "/awolski/Sent")
                   (mu4e-refile-folder     . "/awolski/Archive")
                   (mu4e-trash-folder      . "/awolski/Trash")))

          ;; yvant.io account
          (make-mu4e-context
           :name "yvant"
           :match-func
           (lambda (msg)
             (when msg
               (string-prefix-p "/yvant" (mu4e-message-field msg :maildir))))
           :vars '((user-mail-address      . "tony@yvant.coop")
                   (user-full-name         . "Tony Wolski")
                   (mu4e-compose-signature . "Tony\n\n\https://yvant.coop")
                   (smtpmail-smtp-user     . "tony@yvant.coop")
                   (smtpmail-smtp-server   . "smtp.fastmail.com")
                   (smtpmail-smtp-service  . 587)
                   (smtpmail-stream-type   . starttls)
                   (mu4e-drafts-folder     . "/yvant/Drafts")
                   (mu4e-sent-folder       . "/yvant/Sent")
                   (mu4e-refile-folder     . "/yvant/Archive")
                   (mu4e-trash-folder      . "/yvant/Trash")))))

   (setq mu4e-maildir-shortcuts
         '(("/awolski/Inbox"   . ?i)
           ("/awolski/Archive" . ?a)
           ("/awolski/Trash"   . ?t)
           ("/yvant/Inbox"     . ?j)
           ("/yvant/Archive"   . ?k)
           ("/yvant/Trash"     . ?l)))

   ;; Empty the initial bookmark list
   (setq mu4e-bookmarks '())

   ;; All inboxes
   (defvar inbox-folders (string-join '("maildir:/awolski/INBOX"
                                        "maildir:/yvant/INBOX")
                                        " OR "))

;;   (add-to-list 'mu4e-bookmarks
;;                '(inbox-folders "Inbox" ?i))

   ;; Prevent mu4e from permanently deleting trashed items
   ;; This snippet was taken from the following article:
   ;; http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/
   (defun remove-nth-element (nth list)
     (if (zerop nth) (cdr list)
       (let ((last (nthcdr (1- nth) list)))
         (setcdr last (cddr last))
         list)))

   (setq mu4e-marks (remove-nth-element 5 mu4e-marks))
   (add-to-list 'mu4e-marks
                '(trash
                  :char ("d" . "▼")
                  :prompt "dtrash"
                  :dyn-target (lambda (target msg) (mu4e-get-trash-folder msg))
                  :action (lambda (docid msg target)
                            (mu4e~proc-move docid
                                            (mu4e~mark-check-target target) "-N"))))


   ;; Close the message after I've sent it
   (setq message-kill-buffer-on-exit t)
   ;; Don't ask for a 'context' upon opening mu4e
   (setq mu4e-context-policy 'pick-first)
   ;; Don't ask to quit
   (setq mu4e-confirm-quit nil)
   #+end_src

   View and reply to iCalendar events.

   #+begin_src emacs-lisp
   (require 'mu4e-icalendar)
   (mu4e-icalendar-setup)

   ;; Trash invitations after sending a response
   (setq mu4e-icalendar-trash-after-reply t)
   #+end_src

** Visual

   Change the color-theme to =doom-one=.

   #+BEGIN_SRC emacs-lisp
   (load-theme 'doom-one t)
   #+END_SRC

   =doom-one-light= is my preferred light theme, but =doom-one= makes a very nice
   dark theme. I want to be able to cycle between these.

   #+BEGIN_SRC emacs-lisp
   (defun cycle-themes ()
     "Returns a function that lets you cycle your themes."
     (let ((themes '#1=(doom-one-light doom-one . #1#)))
       (lambda ()
         (interactive)
         ;; Rotates the thme cycle and changes the current theme.
         (load-theme (car (setq themes (cdr themes))) t)
         (message (concat "Switched to " (symbol-name (car themes)))))))
   #+END_SRC

   Use the [[http://www.levien.com/type/myfonts/inconsolata.html][Inconsolata]] font if it's installed on the system.

   #+BEGIN_SRC emacs-lisp
   (cond ((member "Hasklig" (font-family-list))
          (set-face-attribute 'default nil :font "Hasklig-14"))
         ((member "Inconsolata" (font-family-list))
          (set-face-attribute 'default nil :font "Inconsolata-14")))
   #+END_SRC

   Let's pick out the my favorite elements from [[https://github.com/rougier/elegant-emacs][elegant emacs]]! It looks really
   nice.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'default-frame-alist '(internal-border-width . 12))

   ;; simplified mode line
   (define-key mode-line-major-mode-keymap [header-line]
     (lookup-key mode-line-major-mode-keymap [mode-line]))

   (defun mode-line-render (left right)
     (let* ((available-width (- (window-total-width) (length left))))
       (format (format "%%s %%%ds" available-width) left right)))

   (setq-default
    header-line-format
    '((:eval
       (propertize
        (mode-line-render
         (format-mode-line
          (list (propertize "☰" 'face `(:inherit mode-line-buffer-id)
                            'help-echo "Mode(s) menu"
                            'mouse-face 'mode-line-highlight
                            'local-map   mode-line-major-mode-keymap)
                " %b "
                (if (and buffer-file-name (buffer-modified-p))
                    (propertize "(modified)" 'face `(:inherit font-lock-comment-face)))))
         (format-mode-line
          (propertize "%4l:%2c  " 'face
                      `(:inherit font-lock-comment-face))))
        'face `(:underline ,(face-foreground 'font-lock-comment-face))))))

   ;(setq-default mode-line-format nil)
   #+END_SRC

   New in Emacs 24.4 is the =prettify-symbols-mode=! It's neat.

   #+BEGIN_SRC emacs-lisp
   (setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                          ("delta" . ?Δ)
                                          ("gamma" . ?Γ)
                                          ("phi" . ?φ)
                                          ("psi" . ?ψ)))
   #+END_SRC

   [[https://github.com/rnkn/olivetti][Olivetti]] is a package that simply centers the text of a buffer. It is very
   simple and beautiful. The default width is just a bit short.

   #+BEGIN_SRC emacs-lisp
   (with-eval-after-load 'olivetti
     (setq-default olivetti-body-width 82)
     (remove-hook 'olivetti-mode-on-hook 'visual-line-mode))
   #+END_SRC

[[https://ox-hugo.scripter.co/][ox-hugo]] is an Org exporter backend that exports Org to [[https://gohugo.io/][Hugo]]-compatible Markdown
(Blackfriday). With it we can write format). With it we can keep all our posts
in a single org file.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox
  (require 'ox-hugo))
#+END_SRC

** Ivy

   Let's try [[http://oremacs.com/swiper/][Ivy]] in favor of helm.

   #+begin_src emacs-lisp
   (setq ivy-wrap t
         ivy-height 25
         ivy-use-virtual-buffers t
         ivy-count-format "(%d/%d) "
         ivy-on-del-error-function 'ignore)
   (ivy-mode 1)
   #+end_src

** Magit

Magit is awesome. Let's use [[https://github.com/magit/forge][Forge]] too.

   #+begin_src emacs-lisp
   (with-eval-after-load 'magit
     (require 'forge))
   #+end_src

** COMMENT  EMMS

It's quite convenient to be able to control media from within Emacs. [[https://www.emacswiki.org/emacs/EMMS][EMMS]]
coupled with
[[https://itsfoss.com/mpv-video-player/][mpv]] is a great lightweight choice.

#+begin_src emacs-lisp
(require 'emms-setup)
(emms-all)
(setq emms-player-list '(emms-player-mpv))
(setq emms-source-file-default-directory "~/media")
#+end_src

** PDF Tools

   [[https://github.com/politza/pdf-tools][PDF Tools]] makes a huge improvement on the built-in [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][doc-view-mode]]; the only
   drawback is the =pdf-tools-install= (which has to be executed before the
   package can be used) takes a couple of /seconds/ to execute. Instead of
   running it at init-time, we'll run it whenever a PDF is opened. Note that
   it's only slow on the first run!

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-tools-install))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (add-hook 'pdf-view-mode-hook
             (lambda () (setq header-line-format nil)))
   #+END_SRC

** Completion

   [[https://github.com/auto-complete/auto-complete][Auto-Complete]] has been a part of my config for years, but I want to try
   out [[http://company-mode.github.io/][company-mode]]. If I code in an environment with good completion, I've
   made an habit of trying to /guess/ function-names, and looking at the
   completions for the right one. So I want a pretty aggressive completion
   system, hence the no delay settings and short prefix length.

   #+BEGIN_SRC emacs-lisp
   (setq company-idle-delay 0
         company-echo-delay 0
         company-dabbrev-downcase nil
         company-minimum-prefix-length 2
         company-selection-wrap-around t
         company-transformers '(company-sort-by-occurrence
                                company-sort-by-backend-importance))
   #+END_SRC

** Spelling

   Flyspell offers on-the-fly spell checking. Let's Use aspell instead of ispell.

   #+BEGIN_SRC emacs-lisp
   (setq ispell-list-command "--list")
   #+END_SRC

   We can enable flyspell for all text-modes with this snippet.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'text-mode-hook 'turn-on-flyspell)
   #+END_SRC

   To use flyspell for programming there is =flyspell-prog-mode=, that only
   enables spell checking for comments and strings. We can enable it for all
   programming modes using the =prog-mode-hook=.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'prog-mode-hook 'flyspell-prog-mode)
   #+END_SRC

   When working with several languages, we should be able to cycle through
   the languages we most frequently use. Every buffer should have a separate
   cycle of languages, so that cycling in one buffer does not change the
   state in a different buffer (this problem occurs if you only have one
   global cycle). We can implement this by using a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Closures.html][closure]].

   #+BEGIN_SRC emacs-lisp
   (defun cycle-languages ()
     "Changes the ispell dictionary to the first element in
   ISPELL-LANGUAGES, and returns an interactive function that cycles
   the languages in ISPELL-LANGUAGES when invoked."
     (let ((ispell-languages '#1=("british" "american" . #1#)))
       (ispell-change-dictionary (car ispell-languages))
       (lambda ()
         (interactive)
         ;; Rotates the languages cycle and changes the ispell dictionary.
         (ispell-change-dictionary
          (car (setq ispell-languages (cdr ispell-languages)))))))
   #+END_SRC

   =flyspell= signals an error if there is no spell-checking tool is
   installed. We can advice =turn-on-flyspell= and =flyspell-prog-mode= to
   only try to enable =flyspell= if a spell-checking tool is available. Also
   we want to enable cycling the languages by typing =C-c l=, so we bind the
   function returned from =cycle-languages=.

   #+BEGIN_SRC emacs-lisp
   (defadvice turn-on-flyspell (before check nil activate)
     "Turns on flyspell only if a spell-checking tool is installed."
     (when (executable-find ispell-program-name)
       (local-set-key (kbd "C-c i") (cycle-languages))))
   #+END_SRC

** Ledger

I use [[https://www.ledger-cli.org/][Ledger]] to keep track of my financial life. The default alignment for post
amounts is too narrow.

#+BEGIN_SRC emacs-lisp
;;(setq ledger-post-amount-alignment-column 60)
#+END_SRC

** COMMENT Org Roam

   Trying out [[https://www.orgroam.com/][org-roam]] for organizing notes.

   #+begin_src emacs-lisp
   (setq org-roam-directory "~/Dropbox/org-roam")
   (add-hook 'after-init-hook 'org-roam-mode)

   (setq org-roam-dailies-capture-templates
         '(("d" "dagbok" entry
            #'org-roam-capture--get-point
            "\n* %?"
            :file-name "daily/dagbok-%<%Y-%m-%d>"
            :head "#+title: Dagbok %<%Y-%m-%d>\n")

           ("r" "reading" entry
            #'org-roam-capture--get-point
            "\n* %?"
            :file-name "daily/reading-%<%Y-%m-%d>"
            :head "#+title: Reading %<%Y-%m-%d>\n")))

   (with-eval-after-load 'org-roam
     (define-key org-roam-mode-map (kbd "C-c r l") 'org-roam)
     (define-key org-roam-mode-map (kbd "C-c r d") 'org-roam-dailies-today)
     (define-key org-roam-mode-map (kbd "C-c r f") 'org-roam-find-file)
     (define-key org-roam-mode-map (kbd "C-c r g") 'org-roam-graph)

     (define-key org-mode-map (kbd "C-c r i") 'org-roam-insert)
     (define-key org-mode-map (kbd "C-c r I") 'org-roam-insert-immediate))
   #+end_src

   #+begin_src emacs-lisp
   (setq org-roam-server-host "127.0.0.1"
         org-roam-server-port 8080
         org-roam-server-authenticate nil
         org-roam-server-export-inline-images t
         org-roam-server-serve-files nil
         org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
         org-roam-server-network-poll t
         org-roam-server-network-arrows nil
         org-roam-server-network-label-truncate t
         org-roam-server-network-label-truncate-length 60
         org-roam-server-network-label-wrap-length 20)
   #+end_src

   ;;** Interactive functions
   ;;   <<sec:defuns>>
   ;;
   ;;   =just-one-space= removes all whitespace around a point - giving it a
   ;;   negative argument it removes newlines as well. We wrap a interactive
   ;;   function around it to be able to bind it to a key. In Emacs 24.4
   ;;   =cycle-spacing= was introduced, and it works like =just-one-space=, but
   ;;   when run in succession it cycles between one, zero and the original
   ;;   number of spaces.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (defun cycle-spacing-delete-newlines ()
   ;;     "Removes whitespace before and after the point."
   ;;     (interactive)
   ;;     (if (version< emacs-version "24.4")
   ;;         (just-one-space -1)
   ;;       (cycle-spacing -1)))
   ;;   #+END_SRC
   ;;
   ;;   Often I want to find other occurrences of a word I'm at, or more
   ;;   specifically the symbol (or tag) I'm at. The
   ;;   =isearch-forward-symbol-at-point= in Emacs 24.4 works well for this, but
   ;;   I don't want to be bothered with the =isearch= interface. Rather jump
   ;;   quickly between occurrences of a symbol, or if non is found, don't do
   ;;   anything.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (defun jump-to-symbol-internal (&optional backwardp)
   ;;     "Jumps to the next symbol near the point if such a symbol
   ;;   exists. If BACKWARDP is non-nil it jumps backward."
   ;;     (let* ((point (point))
   ;;            (bounds (find-tag-default-bounds))
   ;;            (beg (car bounds)) (end (cdr bounds))
   ;;            (str (isearch-symbol-regexp (find-tag-default)))
   ;;            (search (if backwardp 'search-backward-regexp
   ;;                      'search-forward-regexp)))
   ;;       (goto-char (if backwardp beg end))
   ;;       (funcall search str nil t)
   ;;       (cond ((<= beg (point) end) (goto-char point))
   ;;             (backwardp (forward-char (- point beg)))
   ;;             (t  (backward-char (- end point))))))
   ;;
   ;;   (defun jump-to-previous-like-this ()
   ;;     "Jumps to the previous occurrence of the symbol at point."
   ;;     (interactive)
   ;;     (jump-to-symbol-internal t))
   ;;
   ;;   (defun jump-to-next-like-this ()
   ;;     "Jumps to the next occurrence of the symbol at point."
   ;;     (interactive)
   ;;     (jump-to-symbol-internal))
   ;;   #+END_SRC
   ;;
   ;;   I sometimes regret killing the =*scratch*=-buffer, and have realized I
   ;;   never want to actually kill it. I just want to get it out of the way, and
   ;;   clean it up. The function below does just this for the
   ;;   =*scratch*=-buffer, and works like =kill-this-buffer= for any other
   ;;   buffer. It removes all buffer content and buries the buffer (this means
   ;;   making it the least likely candidate for =other-buffer=).
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (defun kill-this-buffer-unless-scratch ()
   ;;     "Works like `kill-this-buffer' unless the current buffer is the
   ;;   ,*scratch* buffer. In witch case the buffer content is deleted and
   ;;   the buffer is buried."
   ;;     (interactive)
   ;;     (if (not (string= (buffer-name) "*scratch*"))
   ;;         (kill-this-buffer)
   ;;       (delete-region (point-min) (point-max))
   ;;       (switch-to-buffer (other-buffer))
   ;;       (bury-buffer "*scratch*")))
   ;;   #+END_SRC
   ;;
   ;;   To duplicate either selected text or a line we define this interactive
   ;;   function.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (defun duplicate-thing (comment)
   ;;     "Duplicates the current line, or the region if active. If an argument is
   ;;   given, the duplicated region will be commented out."
   ;;     (interactive "P")
   ;;     (save-excursion
   ;;       (let ((start (if (region-active-p) (region-beginning) (point-at-bol)))
   ;;             (end   (if (region-active-p) (region-end) (point-at-eol)))
   ;;             (fill-column most-positive-fixnum))
   ;;         (goto-char end)
   ;;         (unless (region-active-p)
   ;;           (newline))
   ;;         (insert (buffer-substring start end))
   ;;         (when comment (comment-region start end)))))
   ;;   #+END_SRC
   ;;
   To tidy up a buffer we define this function borrowed from [[https://github.com/simenheg][simenheg]].

   #+BEGIN_SRC emacs-lisp
   (defun tidy ()
     "Ident, untabify and unwhitespacify current buffer, or region if active."
     (interactive)
     (let ((beg (if (region-active-p) (region-beginning) (point-min)))
           (end (if (region-active-p) (region-end) (point-max))))
       (indent-region beg end)
       (whitespace-cleanup)
       (untabify beg (if (< end (point-max)) end (point-max)))))
   #+END_SRC

   ;;   Org mode does currently not support synctex (which enables you to jump from
   ;;   a point in your TeX-file to the corresponding point in the pdf), and it
   ;;   [[http://comments.gmane.org/gmane.emacs.orgmode/69454][seems like a tricky problem]].
   ;;
   ;;   Calling this function from an org-buffer jumps to the corresponding section
   ;;   in the exported pdf (given that the pdf-file exists), using pdf-tools.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (defun org-sync-pdf ()
   ;;     (interactive)
   ;;     (let ((headline (nth 4 (org-heading-components)))
   ;;           (pdf (concat (file-name-base (buffer-name)) ".pdf")))
   ;;       (when (file-exists-p pdf)
   ;;         (find-file-other-window pdf)
   ;;         (pdf-links-action-perform
   ;;          (cl-find headline (pdf-info-outline pdf)
   ;;                   :key (lambda (alist) (cdr (assoc 'title alist)))
   ;;                   :test 'string-equal)))))
   ;;   #+END_SRC
   ;;
** Org Mode

Activate Org Babel languages.

   #+begin_src emacs-lisp
   (org-babel-do-load-languages
    'org-babel-load-languages
    '((http . t)
      (ledger . t)
      (shell . t)))
   #+end_src

Use the key bindings suggested in Org mode's [[https://orgmode.org/manual/Activation.html][activation]] document.

   #+begin_src emacs-lisp
   (global-set-key (kbd "C-c l") #'org-store-link)
   (global-set-key (kbd "C-c a") #'org-agenda)
   (global-set-key (kbd "C-c c") #'org-capture)
   #+end_src

Use sane defaults.

#+begin_src emacs-lisp
(setq org-directory "~/org"
      org-agenda-files (list org-directory)
      org-default-notes-file (concat org-directory "/refile.org")
      org-fold-catch-invisible-edits 'smart
      org-hierarchical-todo-statistics nil
      org-startup-folded t
      org-startup-indented t
      org-duration-format 'h:mm
      org-log-done t
      org-log-into-drawer "LOGBOOK"
      org-agenda-window-setup 'current-window)
#+end_src

   Enable org-habit module.

   #+begin_src emacs-lisp
   (add-to-list 'org-modules 'org-habit)
   #+end_src

   Refiling...

   #+begin_src emacs-lisp
   (setq org-refile-use-outline-path 'file
         org-outline-path-complete-in-steps nil
         org-refile-targets '((org-agenda-files :maxlevel . 9)))
   #+end_src

   Enable iCalendar to Org sync functionality for [[https://www.djcbsoftware.nl/code/mu/mu4e/iCalendar.html][mu4e]].

   #+begin_src emacs-lisp
   (setq gnus-icalendar-org-capture-file "~/org/refile.org")
   (setq gnus-icalendar-org-capture-headline '(""))
   (gnus-icalendar-org-setup)

   ;; Extract the event time directly from the iCalendar event
   (defun my-catch-event-time (orig-fun &rest args)
     "Set org-overriding-default-time to the start time of the capture event"
     (let ((org-overriding-default-time (date-to-time
                                         (gnus-icalendar-event:start (car args)))))
       (apply orig-fun args)))

   (advice-add 'gnus-icalendar:org-event-save :around #'my-catch-event-time)
   #+end_src

   Use Org Crypt.

   #+begin_src emacs-lisp
   (require 'org-crypt)
   (org-crypt-use-before-save-magic)
   (setq org-tags-exclude-from-inheritance '("crypt"))

   (setq org-crypt-key "0x72CA03529FF0C81C")
   ;; GPG key to use for encryption.
   ;; nil means  use symmetric encryption unconditionally.
   ;; "" means use symmetric encryption unless heading sets CRYPTKEY property.

   (setq auto-save-default nil)
   ;; Auto-saving does not cooperate with org-crypt.el: so you need to
   ;; turn it off if you plan to use org-crypt.el quite often.  Otherwise,
   ;; you'll get an (annoying) message each time you start Org
   #+end_src

Keywords for todo states.

   #+begin_src emacs-lisp
   (setq org-todo-keywords
         (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!/!)")
                 (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

   (setq org-todo-keyword-faces
         (quote (("TODO" :foreground "#e76f51" :weight bold)
                 ("NEXT" :foreground "#289d8f" :weight bold)
                 ("DONE" :foreground "#6b705c" :weight bold)
                 ("WAITING" :foreground "#f4a261" :weight bold)
                 ("HOLD" :foreground "#e9c46a" :weight bold)
                 ("CANCELLED" :foreground "#6b705c" :weight bold)
                 ("MEETING" :foreground "#6b705c" :weight bold)
                 ("PHONE" :foreground "#6b705c" :weight bold))))

   (setq org-todo-state-tags-triggers
         (quote (("CANCELLED" ("CANCELLED" . t))
                 ("WAITING" ("WAITING" . t))
                 ("HOLD" ("WAITING") ("HOLD" . t))
                 (done ("WAITING") ("HOLD"))
                 ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                 ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                 ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
   #+end_src

Global column view.

   #+begin_src emacs-lisp
   ; Set default column view headings: Task Effort Clock_Summary
   (setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")

   ; global Effort estimate values
   ; global STYLE property values for completion
   (setq org-global-properties (quote (("Effort_ALL" . "0:05 0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                       ("STYLE_ALL" . "habit"))))
   #+end_src

Quick access to Org tags.

   #+begin_src emacs-lisp
   ; Tags with fast selection keys
   (setq org-tag-alist (quote ((:startgroup)
                               ("@errand" . ?e)
                               ("@office" . ?o)
                               ("@home" . ?H)
                               (:endgroup)
                               ("WAITING" . ?w)
                               ("HOLD" . ?h)
                               ("PERSONAL" . ?p)
                               ("EIRA" . ?E)
                               ("BODHI" . ?B)
                               ("WORK" . ?W)
                               ("ORG" . ?O)
                               ("AWOLSKI" . ?N)
                               ("crypt" . ?c)
                               ("NOTE" . ?n)
                               ("CANCELLED" . ?C)
                               ("FLAGGED" . ??))))

   ; ALLOW SETTING SINGLE tags without the menu
   (setq org-fast-tag-selection-single-key (quote expert))

   ; For tag searches ignore tasks with scheduled and deadline dates
   (setq org-agenda-tags-todo-honor-ignore-options t)
   #+end_src

Configure custom agenda views.

   #+begin_src emacs-lisp
   ;; Do not dim blocked tasks
   (setq org-agenda-dim-blocked-tasks nil)

   ;; Compact the block agenda view
   (setq org-agenda-compact-blocks t)

   (setq org-agenda-custom-commands
         '(("N" "Notes" tags "NOTE"
            ((org-agenda-overriding-header "Notes")
             (org-tags-match-list-sublevels t)))
           ("h" "Habits" tags-todo "STYLE=\"habit\""
            ((org-agenda-overriding-header "Habits")
             (org-agenda-sorting-strategy
              '(todo-states-down effort-up category-keep))))
           ("b" "Bookmarks" tags "BOOKMARK"
            ((org-agenda-overriding-header "Bookmarks")
             (org-tags-match-list-sublevels t)))
           (" " "Agenda"
            ((agenda "" ((org-agenda-span 1)))
             (tags "REFILE"
                   ((org-agenda-overriding-header "Tasks to Refile")
                    (org-tags-match-list-sublevels nil)))
             (tags-todo "-CANCELLED/!"
                        ((org-agenda-overriding-header "Stuck Projects")
                         (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                         (org-agenda-sorting-strategy
                          '(category-keep))))
             (tags-todo "-CANCELLED/!NEXT"
                        ((org-agenda-overriding-header (concat "Next Tasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-projects-and-habits)
                         (org-tags-match-list-sublevels t)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-sorting-strategy
                          '(todo-state-down effort-up category-keep))))
             (tags-todo "-HOLD-CANCELLED/!"
                        ((org-agenda-overriding-header "Projects")
                         (org-agenda-skip-function 'bh/skip-non-projects)
                         (org-tags-match-list-sublevels 'indented)
                         (org-agenda-sorting-strategy
                          '(category-keep))))
             (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                        ((org-agenda-overriding-header (concat "Project Subtasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-non-project-tasks)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-sorting-strategy
                          '(category-keep))))
             (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                        ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-project-tasks)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-sorting-strategy
                          '(priority-down))))
             (tags-todo "-CANCELLED+WAITING|HOLD/!"
                        ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                               (if bh/hide-scheduled-and-waiting-next-tasks
                                                                   ""
                                                                 " (including WAITING and SCHEDULED tasks)")))
                         (org-agenda-skip-function 'bh/skip-non-tasks)
                         (org-tags-match-list-sublevels nil)
                         (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                         (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)))
             ))))
   #+end_src

   #+begin_src emacs-lisp
   (setq org-use-fast-todo-selection t)
   #+end_src

Capture templates for notes, todo etc.

#+begin_src emacs-lisp
(setq org-capture-templates
      '(("t" "Task" entry (file "~/org/refile.org")
         "* TODO %?\n%u\n%a\n" :clock-in t :clock-resume t)
        ("c" "Call" entry (file "~/org/refile.org")
         "* TODO Call %? :@mobile:\n%u\n" :clock-in t :clock-resume t)
        ("m" "Message" entry (file "~/org/refile.org")
         "* TODO Message %? :@mobile:\n%u\n" :clock-in t :clock-resume t)
        ("r" "Respond" entry (file "~/org/refile.org")
         "* NEXT Respond to %:from on %:subject :EMAIL:\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
        ("b" "Bookmark" entry (file "~/org/refile.org")
         "* %? %(org-set-tags \"BOOKMARK\") \n:PROPERTIES:\n:CREATED: %U\n:END:\n\n" :empty-lines 1)
        ("n" "Note" entry (file  "~/org/refile.org")
         "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
        ("j" "Journal" entry (file+olp+datetree "~/org/journal.org")
         "* %?\n%U\n" :clock-in t :clock-resume t :tree-type week)
        ("x" "X" entry (file+olp+datetree "~/org/e.org" "Chronology")
         "* %?\n%U\n" :clock-in t :clock-resume t)
        ("g" "Forge Topic" entry (file "~/org/refile.org")
         "* TODO %:description\n%?\n%a\n%u\n" :clock-in t :clock-resume t)
        ("#" "used by gnus-icalendar-org" entry (file "~/org/refile.org")
          "%i %?\n" :time-prompt :clock-in t :clock-resume t)
        ("i" "Meeting" entry (file "~/org/refile.org")
         "* MEETING Meeting with %? :MEETING:\n%U" :clock-in t :clock-resume t)
        ("p" "Phone call" entry (file "~/org/refile.org")
          "* PHONE Call with %? :PHONE:\n%U" :clock-in t :clock-resume t)
        ("e" "Exercise" item (file+headline "~/org/todo.org" "TODO Exercise")
          "%^u: %?")
        ("h" "Habit" entry (file "~/org/refile.org")
          "* TODO %? :habit: \nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: TODO\n:END:\n%U\n%a\n")))
#+end_src

Keybindings straight to capture templates.

   #+begin_src emacs-lisp
   ;;(define-key global-map (kbd "C-c r")
   ;;  (lambda () (interactive) (org-capture nil "r")))
   #+end_src

When editing org-files with source-blocks, we want the source blocks to be
themed as they would in their native mode.

   #+BEGIN_SRC emacs-lisp
   (setq org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-confirm-babel-evaluate nil
         org-edit-src-content-indentation 0)
   #+END_SRC

Let's test out [[https://github.com/bastibe/org-journal][org-journal]] for journaling.

#+BEGIN_SRC emacs-lisp
(setq org-journal-dir "~/org/journal/"
      org-journal-file-type 'monthly
      org-journal-file-format "%Y-%m.org"
      org-journal-date-format "%Y-%m-%d %a")

(setq tramp-verbose 6)
#+END_SRC


Org helper functions.

   #+begin_src emacs-lisp
   (defun bh/is-project-p ()
     "Any task with a todo keyword subtask"
     (save-restriction
       (widen)
       (let ((has-subtask)
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
         (save-excursion
           (forward-line 1)
           (while (and (not has-subtask)
                       (< (point) subtree-end)
                       (re-search-forward "^\*+ " subtree-end t))
             (when (member (org-get-todo-state) org-todo-keywords-1)
               (setq has-subtask t))))
         (and is-a-task has-subtask))))

   (defun bh/is-project-subtree-p ()
     "Any task with a todo keyword that is in a project subtree.
                    Callers of this function already widen the buffer view."
     (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                 (point))))
       (save-excursion
         (bh/find-project-task)
         (if (equal (point) task)
             nil
           t))))

   (defun bh/is-task-p ()
     "Any task with a todo keyword and no subtask"
     (save-restriction
       (widen)
       (let ((has-subtask)
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
         (save-excursion
           (forward-line 1)
           (while (and (not has-subtask)
                       (< (point) subtree-end)
                       (re-search-forward "^\*+ " subtree-end t))
             (when (member (org-get-todo-state) org-todo-keywords-1)
               (setq has-subtask t))))
         (and is-a-task (not has-subtask)))))

   (defun bh/is-subproject-p ()
     "Any task which is a subtask of another project"
     (let ((is-subproject)
           (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
       (save-excursion
         (while (and (not is-subproject) (org-up-heading-safe))
           (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
             (setq is-subproject t))))
       (and is-a-task is-subproject)))

   (defun bh/list-sublevels-for-projects-indented ()
     "Set org-tags-match-list-sublevels so when restricted to a subtree
            we list all subtasks. This is normally used by skipping functions where
          this variable is already local to the agenda."

     (if (marker-buffer org-agenda-restrict-begin)
         (setq org-tags-match-list-sublevels 'indented)
       (setq org-tags-match-list-sublevels nil))
     nil)

   (defun bh/list-sublevels-for-projects ()
     "Set org-tags-match-list-sublevels so when restricted to a subtree
                we list all subtasks.  This is normally used by skipping functions
                where this variable is already local to the agenda."
     (if (marker-buffer org-agenda-restrict-begin)
         (setq org-tags-match-list-sublevels t)
       (setq org-tags-match-list-sublevels nil))
     nil)

   (defvar bh/hide-scheduled-and-waiting-next-tasks t)

   (defun bh/toggle-next-task-display ()
     (interactive)
     (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
     (when  (equal major-mode 'org-agenda-mode)
       (org-agenda-redo))
     (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

   (defun bh/skip-non-stuck-projects ()
     "Skip trees that are not stuck projects"
     ;; (bh/list-sublevels-for-projects-indented)
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (if (bh/is-project-p)
             (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                    (has-next ))
               (save-excursion
                 (forward-line 1)
                 (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                   (unless (member "WAITING" (org-get-tags))
                     (setq has-next t))))
               (if has-next
                   next-headline
                 nil)) ; a stuck project, has subtasks but no next task
           next-headline))))

   (defun bh/skip-non-projects ()
     "Skip trees that are not projects"
     ;; (bh/list-sublevels-for-projects-indented)
     (if (save-excursion (bh/skip-non-stuck-projects))
         (save-restriction
           (widen)
           (let ((subtree-end (save-excursion (org-end-of-subtree t))))
             (cond
              ((bh/is-project-p)
               nil)
              ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
               nil)
              (t
               subtree-end))))
       (save-excursion (org-end-of-subtree t))))

   (defun bh/skip-non-tasks ()
     "Show non-project tasks.
       Skip project and sub-project tasks, habits, and project related tasks."
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (cond
          ((bh/is-task-p)
           nil)
          (t
           next-headline)))))

   (defun bh/skip-project-trees-and-habits ()
     "Skip trees that are projects"
     (save-restriction
       (widen)
       (let ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((bh/is-project-p)
           subtree-end)
          ;;       ((org-is-habit-p)
          ;;        subtree-end)
          (t
           nil)))))

   (defun bh/skip-projects-and-habits-and-single-tasks ()
     "Skip trees that are projects, tasks that are habits, single non-project tasks"
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (cond
          ;;       ((org-is-habit-p)
          ;;        next-headline)
          ((and bh/hide-scheduled-and-waiting-next-tasks
                (member "WAITING" (org-get-tags)))
           next-headline)
          ((bh/is-project-p)
           next-headline)
          ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
           next-headline)
          (t
           nil)))))

   (defun bh/skip-project-tasks-maybe ()
     "Show tasks related to the current restriction.
    When restricted to a project, skip project and sub project tasks, habits, NEXT
     tasks, and loose tasks. When not restricted, skip project and sub-project
     tasks, habits, and project related tasks."
     (save-restriction
       (widen)
       (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
              (next-headline (save-excursion (or (outline-next-heading) (point-max))))
              (limit-to-project (marker-buffer org-agenda-restrict-begin)))
         (cond
          ((bh/is-project-p)
           next-headline)
          ;;       ((org-is-habit-p)
          ;;        subtree-end)
          ((and (not limit-to-project)
                (bh/is-project-subtree-p))
           subtree-end)
          ((and limit-to-project
                (bh/is-project-subtree-p)
                (member (org-get-todo-state) (list "NEXT")))
           subtree-end)
          (t
           nil)))))

   (defun bh/skip-project-tasks ()
     "Show non-project tasks.
    Skip project and sub-project tasks, habits, and project related tasks."
     (save-restriction
       (widen)
       (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((bh/is-project-p)
           subtree-end)
          ;;       ((org-is-habit-p)
          ;;        subtree-end)
          ((bh/is-project-subtree-p)
           subtree-end)
          (t
           nil)))))

   (defun bh/skip-non-project-tasks ()
     "Show project tasks.
    Skip project and sub-project tasks, habits, and loose non-project tasks."
     (save-restriction
       (widen)
       (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
              (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
         (cond
          ((bh/is-project-p)
           next-headline)
          ;;       ((org-is-habit-p)
          ;;        subtree-end)
          ((and (bh/is-project-subtree-p)
                (member (org-get-todo-state) (list "NEXT")))
           subtree-end)
          ((not (bh/is-project-subtree-p))
           subtree-end)
          (t
           nil)))))

   (defun bh/skip-projects-and-habits ()
     "Skip trees that are projects and tasks that are habits"
     (save-restriction
       (widen)
       (let ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((bh/is-project-p)
           subtree-end)
          ;;       ((org-is-habit-p)
          ;;        subtree-end)
          (t
           nil)))))

   (defun bh/skip-non-subprojects ()
     "Skip trees that are not projects"
     (let ((next-headline (save-excursion (outline-next-heading))))
       (if (bh/is-subproject-p)
           nil
         next-headline)))


   (defun bh/find-project-task ()
     "Move point to the parent (project) task if any"
     (save-restriction
       (widen)
       (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
         (while (org-up-heading-safe)
           (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
             (setq parent-task (point))))
         (goto-char parent-task)
         parent-task)))

   ;;(defun bh/skip-non-archivable-tasks ()
   ;;  "Skip trees that are not available for archiving"
   ;;  (save-restriction
   ;;    (widen)
   ;;    ;; Consider only tasks with done todo headings as archivable candidates
   ;;    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
   ;;          (subtree-end (save-excursion (org-end-of-subtree t))))
   ;;      (if (member (org-get-todo-state) org-todo-keywords-1)
   ;;          (if (member (org-get-todo-state) org-done-keywords)
   ;;              (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
   ;;                     (a-month-ago (* 60 60 24 (+ daynr 1)))
   ;;                     (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
   ;;                     (this-month (format-time-string "%Y-%m-" (current-time)))
   ;;                     (subtree-is-current (save-excursion
   ;;                                           (forward-line 1)
   ;;                                           (and (< (point) subtree-end)
   ;;                                                (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
   ;;                (if subtree-is-current
   ;;                    subtree-end ; Has a date in this month or last month, skip it
   ;;                  nil))  ; available to archive
   ;;            (or subtree-end (point-max)))
   ;;        next-headline))))

   #+end_src

   ;;   This is quite an ugly fix for allowing code markup for expressions like
   ;;   ="this string"=, because the quotation marks causes problems.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (with-eval-after-load 'org
   ;;     (require 'org-tempo)
   ;;     (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,")
   ;;     (custom-set-variables `(org-emphasis-alist ',org-emphasis-alist)))
   ;;   #+END_SRC
   ;;
   Enable org-bullets when opening org-files.

   #+BEGIN_SRC emacs-lisp
   ;;(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
   #+END_SRC

** Advice

   An advice can be given to a function to make it behave differently. This
   advice makes =eval-last-sexp= (bound to =C-x C-e=) replace the sexp with
   the value.

   #+BEGIN_SRC emacs-lisp
   (defadvice eval-last-sexp (around replace-sexp (arg) activate)
     "Replace sexp when called with a prefix argument."
     (if arg
         (let ((pos (point)))
           ad-do-it
           (goto-char pos)
           (backward-kill-sexp)
           (forward-sexp))
       ad-do-it))
   #+END_SRC

   When interactively changing the theme (using =M-x load-theme=), the
   current custom theme is not disabled. This often gives weird-looking
   results; we can advice =load-theme= to always disable themes currently
   enabled themes.

   #+BEGIN_SRC emacs-lisp
   (defadvice load-theme
       (before disable-before-load (theme &optional no-confirm no-enable) activate)
     (mapc 'disable-theme custom-enabled-themes))
   #+END_SRC

** global-scale-mode

   These functions provide something close to ~text-scale-mode~, but for every
   buffer, including the minibuffer and mode line.

   #+BEGIN_SRC emacs-lisp
   (let* ((default (face-attribute 'default :height))
          (size default))

     (defun global-scale-default ()
       (interactive)
       (global-scale-internal (setq size default)))

     (defun global-scale-up ()
       (interactive)
       (global-scale-internal (setq size (+ size 20))))

     (defun global-scale-down ()
       (interactive)
       (global-scale-internal (setq size (- size 20))))

     (defun global-scale-internal (arg)
       (set-face-attribute 'default (selected-frame) :height arg)
       (set-transient-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "C-=") 'global-scale-up)
          (define-key map (kbd "C-+") 'global-scale-up)
          (define-key map (kbd "C--") 'global-scale-down)
          (define-key map (kbd "C-0") 'global-scale-default) map))))
   #+END_SRC

* Mode specific

  ;;** Compilation
  ;;
  ;;   I often run ~latexmk -pdf -pvc~ in a compilation buffer, which recompiles
  ;;   the latex-file whenever it is changed. This often results in annoyingly
  ;;   large compilation buffers; the following snippet limits the buffer size in
  ;;   accordance with ~comint-buffer-maximum-size~, which defaults to 1024 lines.
  ;;
  ;;   #+BEGIN_SRC emacs-lisp
  ;;   (add-hook 'compilation-filter-hook 'comint-truncate-buffer)
  ;;   #+END_SRC
  ;;
** Shell

   Inspired by [[https://github.com/torenord/.emacs.d][torenord]], I maintain quick access to shell buffers with bindings
   ~M-1~ to ~M-9~. In addition, the ~M-§~ (on an international English
   keyboard) toggles between the last visited shell, and the last visited
   non-shell buffer. The following functions facilitate this, and are bound in
   the [[Key bindings]] section.

   #+BEGIN_SRC emacs-lisp
   (let ((last-vterm ""))
     (defun toggle-vterm ()
       (interactive)
       (cond ((string-match-p "^\\vterm<[1-9][0-9]*>$" (buffer-name))
              (goto-non-vterm-buffer))
             ((get-buffer last-vterm) (switch-to-buffer last-vterm))
             (t (vterm (setq last-vterm "vterm<1>")))))

     (defun switch-vterm (n)
       (let ((buffer-name (format "vterm<%d>" n)))
         (setq last-vterm buffer-name)
         (cond ((get-buffer buffer-name)
                (switch-to-buffer buffer-name))
               (t (vterm buffer-name)
                  (rename-buffer buffer-name)))))

     (defun goto-non-vterm-buffer ()
       (let* ((r "^\\vterm<[1-9][0-9]*>$")
              (vterm-buffer-p (lambda (b) (string-match-p r (buffer-name b))))
              (non-vterms (cl-remove-if vterm-buffer-p (buffer-list))))
         (when non-vterms
           (switch-to-buffer (car non-vterms))))))
   #+END_SRC

   Don't query whether or not the ~shell~-buffer should be killed, just kill
   it.

   #+BEGIN_SRC emacs-lisp
   (defadvice vterm (after kill-with-no-query nil activate)
     (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil))
   #+END_SRC
   ;;
   ;;   Use zsh:
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (setq vterm-shell "/usr/local/bin/zsh")
   ;;   #+END_SRC
   ;;
   ;;   I'd like the =C-l= to work more like the standard terminal (which works
   ;;   like running =clear=), and resolve this by simply removing the
   ;;   buffer-content. Mind that this is not how =clear= works, it simply adds a
   ;;   bunch of newlines, and puts the prompt at the top of the window, so it
   ;;   does not remove anything. In Emacs removing stuff is less of a worry,
   ;;   since we can always undo!
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (defun clear-comint ()
   ;;     "Runs `comint-truncate-buffer' with the
   ;;   `comint-buffer-maximum-size' set to zero."
   ;;     (interactive)
   ;;     (let ((comint-buffer-maximum-size 0))
   ;;       (comint-truncate-buffer)))
   ;;   #+END_SRC
   ;;
   ;;** Lisp
   ;;
   ;;   I use =Paredit= when editing lisp code, we enable this for all lisp-modes.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (dolist (mode '(cider-repl-mode
   ;;                   clojure-mode
   ;;                   ielm-mode
   ;;                   racket-mode
   ;;                   racket-repl-mode
   ;;                   slime-repl-mode
   ;;                   lisp-mode
   ;;                   emacs-lisp-mode
   ;;                   lisp-interaction-mode
   ;;                   scheme-mode))
   ;;     ;; add paredit-mode to all mode-hooks
   ;;     (add-hook (intern (concat (symbol-name mode) "-hook")) 'paredit-mode))
   ;;   #+END_SRC
   ;;
   ;;*** Emacs Lisp
   ;;
   ;;    In =emacs-lisp-mode= we can enable =eldoc-mode= to display information
   ;;    about a function or a variable in the echo area.
   ;;
   ;;    #+BEGIN_SRC emacs-lisp
   ;;    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
   ;;    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
   ;;    #+END_SRC
   ;;
   ;;*** Common lisp
   ;;
   ;;    I use [[http://www.common-lisp.net/project/slime/][Slime]] along with =lisp-mode= to edit Common Lisp code. Slime
   ;;    provides code evaluation and other great features, a must have for a
   ;;    Common Lisp developer. [[http://www.quicklisp.org/beta/][Quicklisp]] is a library manager for Common Lisp,
   ;;    and you can install Slime following the instructions from the site along
   ;;    with this snippet.
   ;;
   ;;    #+BEGIN_SRC emacs-lisp
   ;;    (defun activate-slime-helper ()
   ;;      (when (file-exists-p "~/.quicklisp/slime-helper.el")
   ;;        (load (expand-file-name "~/.quicklisp/slime-helper.el"))
   ;;        (define-key slime-repl-mode-map (kbd "C-l")
   ;;          'slime-repl-clear-buffer))
   ;;      (remove-hook 'common-lisp-mode-hook #'activate-slime-helper))
   ;;
   ;;    (add-hook 'common-lisp-mode-hook #'activate-slime-helper)
   ;;    #+END_SRC
   ;;
   ;;    We can specify what Common Lisp program Slime should use (I use SBCL).
   ;;
   ;;    #+BEGIN_SRC emacs-lisp
   ;;    (setq inferior-lisp-program "sbcl")
   ;;    #+END_SRC
   ;;
   ;;    More sensible =loop= indentation, borrowed from [[https://github.com/simenheg][simenheg]].
   ;;
   ;;    #+BEGIN_SRC emacs-lisp
   ;;    (setq lisp-loop-forms-indentation   6
   ;;          lisp-simple-loop-indentation  2
   ;;          lisp-loop-keyword-indentation 6)
   ;;    #+END_SRC
   ;;
   ;;*** Clojure
   ;;
   ;;    Indent neatly when using pattern matching in Clojure.
   ;;
   ;;    #+begin_src emacs-lisp
   ;;    (with-eval-after-load 'clojure-mode
   ;;     (define-clojure-indent
   ;;       (match 1)))
   ;;    #+end_src
   ;;
   ;;** Python
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (setq python-shell-interpreter "python3")
   ;;   (add-hook 'python-mode-hook
   ;;             (lambda () (setq forward-sexp-function nil)))
   ;;   #+END_SRC
   ;;
   ;;** Assembler
   ;;
   ;;   When writing assembler code I use =#= for comments. By defining
   ;;   =comment-start= we can add comments using =M-;= like in other programming
   ;;   modes. Also in assembler should one be able to compile using =C-c C-c=.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (defun asm-setup ()
   ;;     (setq comment-start "#")
   ;;     (local-set-key (kbd "C-c C-c") 'compile))
   ;;
   ;;   (add-hook 'asm-mode-hook 'asm-setup)
   ;;   #+END_SRC
   ;;
   ;;** LaTeX and org-mode LaTeX export
   ;;
   ;;   =.tex=-files should be associated with =latex-mode= instead of
   ;;   =tex-mode=.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))
   ;;   #+END_SRC
   ;;
   ;;   Use [[http://mg.readthedocs.io/latexmk.html][latexmk]] for compilation by default.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (add-hook 'LaTeX-mode-hook
   ;;             (lambda ()
   ;;               (add-hook 'hack-local-variables-hook
   ;;                         (lambda ()
   ;;                          (setq-local compile-command
   ;;                                      (concat "latexmk -pdf -pvc "
   ;;                                              (if (eq TeX-master t)
   ;;                                                  (file-name-base (buffer-name))
   ;;                                                TeX-master))))
   ;;                         t t)))
   ;;   #+END_SRC
   ;;
   ;;   Use ~biblatex~ for bibliography.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (setq-default bibtex-dialect 'biblatex)
   ;;   #+END_SRC
   ;;
   ;;   I like using the [[https://code.google.com/p/minted/][Minted]] package for source blocks in LaTeX. To make org
   ;;   use this we add the following snippet.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (eval-after-load 'org
   ;;     '(add-to-list 'org-latex-packages-alist '("" "minted")))
   ;;   (setq org-latex-listings 'minted)
   ;;   #+END_SRC
   ;;
   ;;   Because [[https://code.google.com/p/minted/][Minted]] uses [[http://pygments.org][Pygments]] (an external process), we must add the
   ;;   =-shell-escape= option to the =org-latex-pdf-process= commands. The
   ;;   =tex-compile-commands= variable controls the default compile command for
   ;;   Tex- and LaTeX-mode, we can add the flag with a rather dirty statement
   ;;   (if anyone finds a nicer way to do this, please let me know).
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (eval-after-load 'tex-mode
   ;;     '(setcar (cdr (cddaar tex-compile-commands)) " -shell-escape "))
   ;;   #+END_SRC
   ;;
   ;;   When exporting from Org to LaTeX, use ~latexmk~ for compilation.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (eval-after-load 'ox-latex
   ;;     '(setq org-latex-pdf-process
   ;;            '("latexmk -pdflatex='pdflatex -shell-escape -interaction nonstopmode' -pdf -f %f")))
   ;;   #+END_SRC
   ;;
   ;;   For my thesis, I need to use our university's LaTeX class, this snippet
   ;;   makes that class available.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (eval-after-load "ox-latex"
   ;;     '(progn
   ;;        (add-to-list 'org-latex-classes
   ;;                     '("ifimaster"
   ;;                       "\\documentclass{ifimaster}
   ;;   [DEFAULT-PACKAGES]
   ;;   [PACKAGES]
   ;;   [EXTRA]
   ;;   \\usepackage{babel,csquotes,ifimasterforside,url,varioref}"
   ;;                      ("\\chapter{%s}" . "\\chapter*{%s}")
   ;;                      ("\\section{%s}" . "\\section*{%s}")
   ;;                      ("\\subsection{%s}" . "\\subsection*{%s}")
   ;;                      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
   ;;                      ("\\paragraph{%s}" . "\\paragraph*{%s}")
   ;;                      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
   ;;        (add-to-list 'org-latex-classes
   ;;                     '("easychair" "\\documentclass{easychair}"
   ;;                      ("\\section{%s}" . "\\section*{%s}")
   ;;                      ("\\subsection{%s}" . "\\subsection*{%s}")
   ;;                      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
   ;;                      ("\\paragraph{%s}" . "\\paragraph*{%s}")
   ;;                      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
   ;;       (custom-set-variables '(org-export-allow-bind-keywords t))))
   ;;   #+END_SRC
   ;;
   ;;   Use Emacs for opening the PDF file, when invoking ~C-c C-e l o~.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (require 'org)
   ;;   (add-to-list 'org-file-apps '("\\.pdf\\'" . emacs))
   ;;   #+END_SRC
   ;;
   ;;** Haskell
   ;;
   ;;   =haskell-doc-mode= is similar to =eldoc=, it displays documentation in
   ;;   the echo area. Haskell has several indentation modes - I prefer using
   ;;   =haskell-indent=.
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
   ;;   (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
   ;;   (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
   ;;   #+END_SRC
   ;;
   ;;   Due to a bug in haskell-mode I have to keep this monstrosity in my config...
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (setq haskell-process-args-ghci
   ;;         '("-ferror-spans" "-fshow-loaded-modules"))
   ;;
   ;;   (setq haskell-process-args-cabal-repl
   ;;         '("--ghc-options=-ferror-spans -fshow-loaded-modules"))
   ;;
   ;;   (setq haskell-process-args-stack-ghci
   ;;         '("--ghci-options=-ferror-spans -fshow-loaded-modules"
   ;;           "--no-build" "--no-load"))
   ;;
   ;;   (setq haskell-process-args-cabal-new-repl
   ;;         '("--ghc-options=-ferror-spans -fshow-loaded-modules"))
   ;;   #+END_SRC
   ;;
   ;;** Coq
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (add-hook 'coq-mode-hook #'company-coq-mode)
   ;;   #+END_SRC
   ;;
** COMMENT Terraform

   #+begin_src emacs-lisp
   (with-eval-after-load 'eglot
     (add-to-list 'eglot-server-programs
                  '(terraform-mode . ("terraform-ls" "serve"))))
   (add-hook 'terraform-mode-hook 'eglot-ensure)
   #+end_src

   # ** Markdown

   #   #+begin_src emacs-lisp
   #   (add-to-list 'eglot-server-programs '(markdown-mode . ("marksman")))
   #   (add-hook 'markdown-mode-hook #'eglot-ensure)
   #   #+end_src

* Key bindings

  Inspired by [[http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs][this StackOverflow post]] I keep a =custom-bindings-map= that
  holds all my custom bindings. This map can be activated by toggling a
  simple =minor-mode= that does nothing more than activating the map. This
  inhibits other =major-modes= to override these bindings. I keep this at
  the end of the init-file to make sure that all functions are actually
  defined.

  #+BEGIN_SRC emacs-lisp
  (defvar custom-bindings-map (make-keymap)
    "A keymap for custom bindings.")
  #+END_SRC

** Bindings for [[https://github.com/abo-abo/define-word][define-word]]

   #+BEGIN_SRC emacs-lisp
   (define-key custom-bindings-map (kbd "C-c D") 'define-word-at-point)
   #+END_SRC

** Bindings for [[https://github.com/magnars/expand-region.el][expand-region]]

   #+BEGIN_SRC emacs-lisp
   (define-key custom-bindings-map (kbd "C->")  'er/expand-region)
   (define-key custom-bindings-map (kbd "C-<")  'er/contract-region)
   #+END_SRC

** Bindings for [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]

   #+BEGIN_SRC emacs-lisp
   (define-key custom-bindings-map (kbd "C-c e")  'mc/edit-lines)
   (define-key custom-bindings-map (kbd "C-c f")  'mc/mark-all-like-this)
   (define-key custom-bindings-map (kbd "C-c n")  'mc/mark-next-like-this)
   #+END_SRC

** Bindings for [[https://magit.vc/][Magit]]

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c m") 'magit-status)
#+END_SRC

** Bindings for [[https://github.com/abo-abo/swiper][Counsel]]

   #+begin_src emacs-lisp
   (global-set-key (kbd "C-c i")   'swiper-isearch)
   (global-set-key (kbd "M-x")     'counsel-M-x)
   (global-set-key (kbd "C-x C-f") 'counsel-find-file)
   (global-set-key (kbd "M-y")     'counsel-yank-pop)
   (global-set-key (kbd "C-x b")   'ivy-switch-buffer)
   #+end_src

** Bindings for [[http://company-mode.github.io/][company-mode]]

   #+BEGIN_SRC emacs-lisp
   (define-key company-active-map (kbd "C-d") 'company-show-doc-buffer)
   (define-key company-active-map (kbd "C-n") 'company-select-next)
   (define-key company-active-map (kbd "C-p") 'company-select-previous)
   (define-key company-active-map (kbd "<tab>") 'company-complete)
   #+END_SRC

** Bindings for [[https://github.com/bbatsov/projectile][Projectile]]

   #+BEGIN_SRC emacs-lisp
   (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
   #+END_SRC

   ;;** Bindings for [[https://github.com/clojure-emacs/cider][Cider]]
   ;;
   ;;   #+BEGIN_SRC emacs-lisp
   ;;   (with-eval-after-load 'cider
   ;;    (define-key cider-repl-mode-map (kbd "C-l") 'cider-repl-clear-buffer))
   ;;   #+END_SRC
   ;;
** Bindings for [[https://github.com/rnkn/olivetti][Olivetti]]

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c o") 'olivetti-mode)
#+END_SRC

** Bindings for org-journal

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c j") 'org-journal-new-entry)
#+END_SRC

** Bindings for built-ins

   #+BEGIN_SRC emacs-lisp
   (define-key custom-bindings-map (kbd "M-u")         'upcase-dwim)
   (define-key custom-bindings-map (kbd "M-c")         'capitalize-dwim)
   (define-key custom-bindings-map (kbd "M-l")         'downcase-dwim)
   (define-key custom-bindings-map (kbd "M-]")         'other-frame)
   (define-key custom-bindings-map (kbd "C-j")         'newline-and-indent)
   (define-key custom-bindings-map (kbd "C-c s")       'ispell-word)
   (define-key comint-mode-map     (kbd "C-l")         'clear-comint)
   #+END_SRC
** Bindings for functions defined [[sec:defuns][above]].

   #+BEGIN_SRC emacs-lisp
   ;;  (define-key global-map          (kbd "M-p")     'jump-to-previous-like-this)
   ;;  (define-key global-map          (kbd "M-n")     'jump-to-next-like-this)
   ;;  (define-key custom-bindings-map (kbd "M-,")     'jump-to-previous-like-this)
   ;;  (define-key custom-bindings-map (kbd "M-.")     'jump-to-next-like-this)
   ;;  (define-key custom-bindings-map (kbd "C-c .")   (cycle-themes))
   ;;  (define-key custom-bindings-map (kbd "C-x k")   'kill-this-buffer-unless-scratch)
   ;;  (define-key custom-bindings-map (kbd "C-c C-0") 'global-scale-default)
   ;;  (define-key custom-bindings-map (kbd "C-c C-=") 'global-scale-up)
   ;;  (define-key custom-bindings-map (kbd "C-c C-+") 'global-scale-up)
   ;;  (define-key custom-bindings-map (kbd "C-c C--") 'global-scale-down)

   ;;  (define-key custom-bindings-map (kbd "C-c j")   'cycle-spacing-delete-newlines)
   ;;  (define-key custom-bindings-map (kbd "C-c d")   'duplicate-thing)
   (define-key custom-bindings-map (kbd "<C-tab>") 'tidy)
   ;;  (define-key custom-bindings-map (kbd "C-z")     'toggle-vterm)
   ;;  (dolist (n (number-sequence 1 9))
   ;;    (global-set-key (kbd (concat "M-" (int-to-string n)))
   ;;                    (lambda () (interactive) (switch-vterm n))))
   ;;  (define-key custom-bindings-map (kbd "C-c C-q")
   ;;    '(lambda ()
   ;;       (interactive)
   ;;       (focus-mode 1)
   ;;       (focus-read-only-mode 1)))
   ;;  (with-eval-after-load 'org
   ;;    (define-key org-mode-map (kbd "C-'") 'org-sync-pdf))
   #+END_SRC

   Lastly we need to activate the map by creating and activating the
   =minor-mode=.

   #+BEGIN_SRC emacs-lisp
   (define-minor-mode custom-bindings-mode
     "A mode that activates custom-bindings."
     :init-value nil
     :keymap custom-bindings-map)
   #+END_SRC

   ;;* License
   ;;
   ;;  My Emacs configurations written in Org mode.
   ;;
   ;;  Copyright (c) 2020 - 2021 Tony Wolski
   ;;
   ;;  This program is free software: you can redistribute it and/or modify
   ;;  it under the terms of the GNU General Public License as published by
   ;;  the Free Software Foundation, either version 3 of the License, or
   ;;  (at your option) any later version.
   ;;
   ;;  This program is distributed in the hope that it will be useful,
   ;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
   ;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   ;;  GNU General Public License for more details.
   ;;
   ;;  You should have received a copy of the GNU General Public License
   ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
